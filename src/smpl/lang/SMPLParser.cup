package smpl.lang;


import java_cup.runtime.*;
import java.io.*;
import java.util.*;


import smpl.lang.*;
import smpl.lang.arith.*;
import smpl.lang.bool.*;
import smpl.lang.chars.*;
import smpl.lang.compound.*;
import smpl.lang.statements.*;
import smpl.lang.string.*;


/* Preliminaries to set up and use the scanner.  */
action code {:          :};

parser code {:
    SMPLLexer lexer;

    public SMPLParser(SMPLLexer l) {
                    super(l);
                    lexer = l;
                }

    public SMPLParser(String file) throws FileNotFoundException {
              this(new SMPLLexer(new FileReader(file)));
    }

                public SMPLParser(InputStream is) {
                    this(new SMPLLexer(new InputStreamReader(is)));
                }

    public void report_error(String message, Object info) {
        System.err.println(message + info);
    }

    public void syntax_error(Symbol cur_token) {
        System.err.print("Line " + lexer.getLine() +
             " near char " + lexer.getChar() + ": ");
        report_error("Syntax error while reading: ", cur_token);
        System.err.println ("Last token read is " +
           lexer.getText());
    }
      :};

init with {:
    // No longer necessary    
    :};
scan with {:
    try {
        return lexer.next_token();
    } catch (java.io.IOException ioe) {
        System.out.println ("Unrecognised token at line: " + 
                                lexer.getLine() + ", char: " + lexer.getChar());
        System.out.println(ioe.getMessage());
        throw ioe;
    }
    :};

/* Terminals (tokens returned by the scanner). */

/* Keywords */
terminal ASSIGN;

/* Arithmetic operators */ 
terminal PLUS, MINUS, TIMES, DIV, MOD;

/* Punctuation */
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, SEMI, COMMA, COLON;
terminal LBCOLON, RBCOLON, QUES;

terminal Integer INTEGER;
terminal Double REAL;
terminal String VAR;
terminal String STRING;
terminal Integer BINARY;
terminal Integer HEX;
terminal String UNICODE;
terminal String CHAR;
terminal String BOOL;
terminal String RATIONAL;
terminal String LOGIC;


// Key Words
terminal CAR, CDR, PAIR, LIST, SIZE, PRINT;

/* Non terminals */

/* *** Logic extensions (in support of IF) *** */
// terminal String CMP;
// terminal IF, ELSE;

// place your extensions here, if you do this problem

/* *** End of logic extensions *** */

non terminal ArrayList<ASTExp<AIRExp>> aExpList;   /* non-empty arith exp list */
non terminal ArrayList<ASTExp<AIRExp>> aExpListE;  /* potentially empty arith exp list */
non terminal ArrayList<ASTExp<SMPLExp>> pExpList;   /* non-empty painter exp list */
non terminal ArrayList<ASTExp<SMPLExp>> pExpListE;  /* potentially empty painter exp list */

non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;
non terminal empty;


// Non-Terminals

non terminal SMPLProgram program;
non terminal StmtSequence stmtList;
non terminal SMPLStatement stmt;
non terminal SMPLExp smplExp;
non terminal ASTExp<AIRExp> arithExp, arithTerm, arithFactor;
non terminal ASTExp<StringExp> stringExp, stringTerm, stringFactor;
non terminal ASTExp<CharExp> charExp, charTerm, charFactor;

non terminal ASTExp<BoolExp> boolExp, boolTerm, boolFactor;
non terminal ASTExp<CompoundExp> pairExp;

non terminal ASTVar varExp;

// VAR:var {: RESULT = new StringLit(var, ""); :}

start with program;

program                         ::=     stmtList:seq {:
                                            RESULT = new SMPLProgram(seq);
                                        :};


stmtList                        ::=     stmtList:seq stmt:s {:
                                            seq.addStatement(s);
                                            RESULT = seq;
                                        :} |

                                        stmt:s {:
                                            StmtSequence seq = new StmtSequence();
                                            seq.addStatement(s);
                                            RESULT = seq;
                                        :};


stmt                            ::=     VAR:id ASSIGN smplExp:exp SEMI {:
                                            RESULT = new SMPLAssignment(id, exp);
                                        :} |

                                        PRINT smplExp:exp SEMI {: RESULT = new PrintStmt(exp); :};


varExp                          ::=     VAR:var {: 
                                            RESULT =  new ASTVar(var);
                                        :};


smplExp                         ::=     pairExp:pair {: RESULT = new SMPLExp(pair); :} |
                                        arithExp:aExp {: RESULT = new SMPLExp(aExp); :} |
                                        stringExp:sExp {: RESULT = new SMPLExp(sExp); :} |
                                        charExp:chExp {: RESULT = new SMPLExp(chExp); :} |
                                        boolExp:bExp {: RESULT = new SMPLExp(bExp); :} |
                                        CAR LPAREN pairExp:exp RPAREN {:
                                            RESULT = new Car(exp); :} |
                                        CDR LPAREN pairExp:exp RPAREN {: 
                                            RESULT = new Cdr(exp); :};


boolExp                         ::=     boolTerm:bool1 LOGIC:op boolExp:bool2 {: 
                                            RESULT = new BinaryCompareExp(op, (BoolExp) bool1, (BoolExp) bool2); 
                                        :} |
                                        LOGIC:op boolExp:bool {: 
                                            RESULT = new BinaryCompareExp(op, (BoolExp) bool);
                                        :} |
                                        boolTerm:bool {: RESULT = bool; :};


boolTerm                        ::=     arithExp:exp1 RATIONAL:op arithExp:exp2 {: 
                                            RESULT = new BinaryCompareExp(op, exp1, exp2); 
                                        :} |

                                        PAIR QUES LPAREN smplExp:exp RPAREN {:
                                            RESULT = null; 
                                        :} | 

                                        boolFactor:bool {: RESULT = bool; :};


boolFactor                      ::=     BOOL:bool {: 
                                            if (bool.equals("#t")) {
                                                RESULT = new BoolExp(true); 
                                            } else {
                                                RESULT = new BoolExp(false);
                                            }
                                        :} |

                                        LPAREN boolExp:bool RPAREN {: RESULT = bool; :};


charExp                         ::=     charTerm:t {: RESULT = t; :};


charTerm                        ::=     charFactor: f {: RESULT = f; :};


charFactor                      ::=     CHAR:ch {: RESULT = new CharLit(ch.charAt(0), "#c"); :} |
                                        UNICODE:uni {: RESULT = new CharLit(uni, "#u"); :};


stringExp                       ::=     stringTerm:t {: RESULT = t; :};


stringTerm                      ::=     stringFactor:f {: RESULT = f; :};


stringFactor                    ::=     STRING:sLit {: RESULT = new StringLit(sLit); :};
                                        


arithExp                        ::=     arithExp:e PLUS arithTerm:t {: RESULT = new ASTBinaryExp("+", e, t); :} |
                                        arithExp:e MINUS arithTerm:t {: RESULT = new ASTBinaryExp("-", e, t); :} |
                                        arithTerm:t {: RESULT = t; :};


arithTerm                       ::=     arithTerm:t TIMES arithFactor:f {: RESULT = new ASTBinaryExp("*", t, f); :} |
                                        arithTerm:t DIV arithFactor:f {: RESULT = new ASTBinaryExp("/", t, f); :} |
                                        arithTerm:t MOD arithFactor:f {: RESULT = new ASTBinaryExp("%", t, f); :} |
                                        arithFactor:f {: RESULT = f; :};

arithFactor                     ::=     INTEGER:alit {: RESULT = new AIRLit(alit, ""); :} |
                                        HEX:hex {: RESULT = new AIRLit(hex, "#x"); :} |
                                        BINARY:bin {: RESULT = new AIRLit(bin, "#b"); :} |
                                        LPAREN MINUS arithTerm:aExp RPAREN {: RESULT = new ASTUnaryExp("-", aExp); :} |
                                        LPAREN arithExp:aexp RPAREN {: RESULT = aexp; :} |
                                        varExp:var {: 
                                            RESULT = var; 
                                        :};     


pairExp                         ::=     PAIR LPAREN smplExp:e1 COMMA smplExp:e2 RPAREN {:
                                            RESULT = new PairExp(e1, e2);
                                        :} |
                                        
                                        varExp:var {: 
                                            RESULT = var; 
                                        :};


empty                           ::=     ;
